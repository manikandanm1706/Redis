import { Injectable } from '@nestjs/common';
import { RedisService } from '@nestjs-modules/ioredis';
import { Redis } from 'ioredis';

@Injectable()
export class RedisServiceClass {
  private readonly redis: Redis;

  constructor(private readonly redisService: RedisService) {
    this.redis = this.redisService.getClient();
  }

  // Add an item with its details
  async addItem(itemKey: string, itemData: Record<string, any>, priceIndex: string, price: number) {
    const pipeline = this.redis.multi();
    pipeline.hmset(itemKey, itemData);
    pipeline.sadd('redishop:all-items', itemKey.split(':')[2]);
    pipeline.zadd(priceIndex, price, itemKey.split(':')[2]);
    await pipeline.exec();
  }

  // Sort items by price and return required fields
  async sortItems(byKeyPattern: string, getField: string[], options: { limit?: [number, number]; desc?: boolean } = {}) {
    let command = this.redis.sort('redishop:all-items', 'BY', byKeyPattern);
    getField.forEach((field) => command = command.get(field));
    
    if (options.limit) {
      command = command.limit(options.limit[0], options.limit[1]);
    }

    if (options.desc) {
      command = command.desc();
    }

    return await command.exec();
  }

  // Fetch items within a price range
  async getItemsByPriceRange(priceIndex: string, min: number, max: number) {
    return await this.redis.zrangebyscore(priceIndex, min, max, 'WITHSCORES');
  }

  // Filter and fetch items using a temporary sorted set
  async filterAndFetchItems(priceIndex: string, min: number, max: number, byKeyPattern: string, getField: string[]) {
    const tempKey = 'temp';
    await this.redis.zunionstore(tempKey, 1, priceIndex);
    await this.redis.zremrangebyscore(tempKey, '-inf', min);
    await this.redis.zremrangebyscore(tempKey, max, '+inf');
    const results = await this.redis.sort(tempKey, 'BY', byKeyPattern, ...getField.flatMap((field) => ['GET', field]));
    await this.redis.del(tempKey);
    return results;
  }

  // Advanced filtering using transactions
  async advancedFilterAndFetch(priceIndex: string, min: number, max: number, byKeyPattern: string, getField: string[]) {
    const tempKey = 'temp';
    const pipeline = this.redis.multi();
    pipeline.zunionstore(tempKey, 1, priceIndex);
    pipeline.zremrangebyscore(tempKey, '-inf', min);
    pipeline.zremrangebyscore(tempKey, max, '+inf');
    pipeline.sort(tempKey, 'BY', byKeyPattern, ...getField.flatMap((field) => ['GET', field]));
    pipeline.del(tempKey);
    const results = await pipeline.exec();
    return results[3][1]; // The sorted result is the fourth command in the pipeline
  }
}


_--------

import { Controller, Get } from '@nestjs/common';

@Controller('redis')
export class RedisController {
  constructor(private readonly redisServiceClass: RedisServiceClass) {}

  @Get('test')
  async test() {
    // Add an item
    await this.redisServiceClass.addItem(
      'redishop:items:Handcrafted-Trees-Mug',
      {
        artist: 'Martin Wessely',
        price: 10.99,
        name: 'Handcrafted Trees Mug',
        description: 'enim corporis voluptatibus...',
        manufacturer: 'OHara-Group',
        itemType: 'mug',
        productImg: 'mug-400_002e1ecb8bd2.jpg',
      },
      'redishop:priceIndex',
      10.99,
    );

    // Sort items
    const sortedItems = await this.redisServiceClass.sortItems(
      'redishop:items:*->price',
      ['redishop:items:*->name', 'redishop:items:*->price'],
      { limit: [0, 5] },
    );

    // Get items by price range
    const itemsByPrice = await this.redisServiceClass.getItemsByPriceRange(
      'redishop:priceIndex',
      10,
      20,
    );

    return { sortedItems, itemsByPrice };
  }
}