I'm using nestjs app. And I'm using postgres db and using nestjs sequelize. I want to prepare query based on the payload. In the payload I will give operator, column, value in a object. Based on this need to prepare where query. And attach to model

On top of this it could be able to mention or or and operator. Based on than condition have to be work

So first show me the payload structure when I say show implementation then give code

Here’s the structure of the payload based on your requirements:

Payload Structure

{
  "conditions": [
    {
      "column": "columnName1",
      "operator": "=", 
      "value": "value1"
    },
    {
      "column": "columnName2",
      "operator": ">",
      "value": "value2"
    }
  ],
  "logicOperator": "AND" // or "OR"
}

Explanation:

1. conditions: An array where each object represents a condition to apply.

column: The column name in your database table.

operator: SQL operator (=, >, <, LIKE, etc.).

value: The value to compare the column against.



2. logicOperator: The logical operator (AND or OR) to combine the conditions.



Example:

1. Using AND:

{
  "conditions": [
    { "column": "age", "operator": ">", "value": 25 },
    { "column": "city", "operator": "=", "value": "Chennai" }
  ],
  "logicOperator": "AND"
}

2. Using OR:

{
  "conditions": [
    { "column": "salary", "operator": ">=", "value": 50000 },
    { "column": "position", "operator": "LIKE", "value": "%developer%" }
  ],
  "logicOperator": "OR"
}

Let me know when you're ready to see the implementation.

If it comes both then how it to be

If you want to support nested conditions where both AND and OR operators can be used in the same payload, the structure can look like this:

Nested Payload Structure

{
  "conditions": [
    {
      "logicOperator": "AND",
      "conditions": [
        { "column": "age", "operator": ">", "value": 25 },
        { "column": "city", "operator": "=", "value": "Chennai" }
      ]
    },
    {
      "logicOperator": "OR",
      "conditions": [
        { "column": "salary", "operator": ">=", "value": 50000 },
        { "column": "position", "operator": "LIKE", "value": "%developer%" }
      ]
    }
  ]
}

Explanation:

1. conditions: An array containing conditions or nested groups of conditions.


2. logicOperator: Indicates how the conditions in a group should be combined (AND or OR).


3. Each group of conditions can itself contain multiple conditions or further nested groups.




---

Example Use Cases:

1. Nested AND and OR:

{
  "conditions": [
    {
      "logicOperator": "AND",
      "conditions": [
        { "column": "age", "operator": ">", "value": 25 },
        { "column": "city", "operator": "=", "value": "Chennai" }
      ]
    },
    {
      "logicOperator": "OR",
      "conditions": [
        { "column": "salary", "operator": ">=", "value": 50000 },
        { "column": "position", "operator": "LIKE", "value": "%developer%" }
      ]
    }
  ]
}

This translates to the SQL query:

WHERE (age > 25 AND city = 'Chennai') 
   OR (salary >= 50000 OR position LIKE '%developer%')

2. Multiple Nesting:

{
  "conditions": [
    {
      "logicOperator": "AND",
      "conditions": [
        {
          "logicOperator": "OR",
          "conditions": [
            { "column": "age", "operator": ">", "value": 25 },
            { "column": "city", "operator": "=", "value": "Chennai" }
          ]
        },
        { "column": "country", "operator": "=", "value": "India" }
      ]
    }
  ]
}

This translates to the SQL query:

WHERE ((age > 25 OR city = 'Chennai') AND country = 'India')

Let me know when you're ready to see the implementation!

It should be more flexible like handle complex and or or but use same pattern

To handle complex AND and OR conditions flexibly using the same pattern, the payload structure can be extended to support nested conditions while maintaining simplicity and consistency.

Flexible Payload Structure

{
  "logicOperator": "AND", 
  "conditions": [
    {
      "logicOperator": "OR",
      "conditions": [
        { "column": "age", "operator": ">", "value": 25 },
        { "column": "city", "operator": "=", "value": "Chennai" }
      ]
    },
    {
      "logicOperator": "AND",
      "conditions": [
        { "column": "salary", "operator": ">=", "value": 50000 },
        { "column": "position", "operator": "LIKE", "value": "%developer%" }
      ]
    },
    { "column": "country", "operator": "=", "value": "India" }
  ]
}

Explanation:

1. logicOperator (Root Level): This specifies how the top-level conditions should be combined. For example:

"AND": All top-level conditions must be true.

"OR": At least one top-level condition must be true.



2. conditions:

Nested Groups: Each group of conditions can have its own logicOperator (AND or OR), allowing infinite nesting.

Leaf Conditions: A leaf condition directly references a column, operator, and value.



3. Combination: Each condition group can have its own combination of AND/OR and multiple nested conditions.




---

Example Use Cases:

1. Complex Nesting with AND and OR:

{
  "logicOperator": "OR",
  "conditions": [
    {
      "logicOperator": "AND",
      "conditions": [
        { "column": "age", "operator": ">", "value": 25 },
        { "column": "city", "operator": "=", "value": "Chennai" }
      ]
    },
    {
      "logicOperator": "AND",
      "conditions": [
        { "column": "salary", "operator": ">=", "value": 50000 },
        { "column": "position", "operator": "LIKE", "value": "%developer%" }
      ]
    }
  ]
}

SQL Equivalent:

WHERE 
  ((age > 25 AND city = 'Chennai') 
   OR 
   (salary >= 50000 AND position LIKE '%developer%'))


---

2. Infinite Nesting for High Flexibility:

{
  "logicOperator": "AND",
  "conditions": [
    {
      "logicOperator": "OR",
      "conditions": [
        {
          "logicOperator": "AND",
          "conditions": [
            { "column": "age", "operator": ">", "value": 25 },
            { "column": "city", "operator": "=", "value": "Chennai" }
          ]
        },
        { "column": "country", "operator": "=", "value": "India" }
      ]
    },
    { "column": "salary", "operator": ">=", "value": 50000 }
  ]
}

SQL Equivalent:

WHERE 
  ((age > 25 AND city = 'Chennai') 
   OR country = 'India') 
  AND salary >= 50000


---

This approach keeps the structure consistent while allowing infinite flexibility for deeply nested conditions. Let me know when you're ready to see the implementation!

Show implementation

Here is the implementation in a NestJS app using Sequelize, designed to build a dynamic query from the flexible payload structure:

Implementation

import { Injectable } from '@nestjs/common';
import { Sequelize, WhereOptions } from 'sequelize';

@Injectable()
export class QueryBuilderService {
  buildWhereQuery(payload: any): WhereOptions {
    const { logicOperator, conditions } = payload;

    // Base case: If conditions are empty or invalid
    if (!conditions || !Array.isArray(conditions)) {
      return {};
    }

    // Recursively build the query
    const query = conditions.map((condition) => {
      if (condition.logicOperator) {
        // Nested group of conditions
        return this.buildWhereQuery(condition);
      } else {
        // Single condition
        const { column, operator, value } = condition;
        return this.mapOperator(column, operator, value);
      }
    });

    // Combine the queries with the specified logical operator (AND/OR)
    return { [Sequelize.Op[logicOperator.toLowerCase()]]: query };
  }

  private mapOperator(column: string, operator: string, value: any) {
    const operatorsMap = {
      '=': Sequelize.Op.eq,
      '>': Sequelize.Op.gt,
      '<': Sequelize.Op.lt,
      '>=': Sequelize.Op.gte,
      '<=': Sequelize.Op.lte,
      '!=': Sequelize.Op.ne,
      'LIKE': Sequelize.Op.like,
      'IN': Sequelize.Op.in,
    };

    const sequelizeOperator = operatorsMap[operator.toUpperCase()];
    if (!sequelizeOperator) {
      throw new Error(`Unsupported operator: ${operator}`);
    }

    return { [column]: { [sequelizeOperator]: value } };
  }
}


---

Usage Example

1. Input Payload:

const payload = {
  logicOperator: 'AND',
  conditions: [
    {
      logicOperator: 'OR',
      conditions: [
        { column: 'age', operator: '>', value: 25 },
        { column: 'city', operator: '=', value: 'Chennai' },
      ],
    },
    {
      logicOperator: 'AND',
      conditions: [
        { column: 'salary', operator: '>=', value: 50000 },
        { column: 'position', operator: 'LIKE', value: '%developer%' },
      ],
    },
    { column: 'country', operator: '=', value: 'India' },
  ],
};

2. Build the Query:

const service = new QueryBuilderService();
const whereQuery = service.buildWhereQuery(payload);
console.log(whereQuery);

3. Output Query (Sequelize Format):

{
  [Op.and]: [
    {
      [Op.or]: [
        { age: { [Op.gt]: 25 } },
        { city: { [Op.eq]: 'Chennai' } }
      ]
    },
    {
      [Op.and]: [
        { salary: { [Op.gte]: 50000 } },
        { position: { [Op.like]: '%developer%' } }
      ]
    },
    { country: { [Op.eq]: 'India' } }
  ]
}

4. Apply the Query to a Model:

const results = await YourModel.findAll({
  where: whereQuery,
});


---

Key Features:

1. Recursive Support: Handles infinite nesting of conditions.


2. Operator Mapping: Maps operators (=, >, LIKE, etc.) to Sequelize equivalents.


3. Flexible Logic: Supports AND and OR at any level.



This implementation ensures flexibility and works efficiently for dynamic queries in Sequelize. Let me know if you need further adjustments!

Now Mark it as version 1.

Now the column would have been relational table so create const it should have allowed filter column, allow sort column, column mapping.allowed filter column holds what are the column going to be filter. Like wise allow sort column holds what are all the column going to be sort. Only these field only they should pass in the payload.

column mapping going to have the keys mentioned on above values of allow filter column and allow sort column. Inside each key should have column which is actual table column name, model which is the column associated with, as which is mentioned on the model when associate other model and last isbasemodel which if the column is base model then it is supposed to be true other wise it supposed to be false.

So based on this const we do validation whether the only allowed columns are passing. And after that when prepare where condition based on this const if the column is relational table column then get respective model and as  add it to include array,

Here’s how you can implement your requirements step-by-step:

Steps to Implement:

1. Define a constant to hold:

Allowed filter columns (allowedFilterColumns).

Allowed sort columns (allowedSortColumns).

Column mapping (columnMapping).



2. Validate the payload to ensure only allowed columns are included.


3. Prepare the where condition using the columnMapping.


4. Add relational table columns to the Sequelize include array dynamically.




---

Code Implementation

1. Define the Constant

const QUERY_CONFIG = {
  allowedFilterColumns: ['age', 'city', 'salary', 'position', 'country', 'departmentName'],
  allowedSortColumns: ['age', 'salary', 'departmentName'],
  columnMapping: {
    age: { column: 'age', model: 'BaseModel', as: null, isBaseModel: true },
    city: { column: 'city', model: 'BaseModel', as: null, isBaseModel: true },
    salary: { column: 'salary', model: 'BaseModel', as: null, isBaseModel: true },
    position: { column: 'position', model: 'BaseModel', as: null, isBaseModel: true },
    country: { column: 'country', model: 'BaseModel', as: null, isBaseModel: true },
    departmentName: {
      column: 'name',
      model: 'Department',
      as: 'department',
      isBaseModel: false,
    },
  },
};


---

2. Validate Payload Columns

This ensures the payload includes only allowed columns.

private validatePayloadColumns(payload: any): void {
  const { conditions } = payload;

  if (!conditions || !Array.isArray(conditions)) {
    throw new Error('Invalid conditions format.');
  }

  conditions.forEach((condition) => {
    if (condition.logicOperator) {
      // Recursively validate nested conditions
      this.validatePayloadColumns(condition);
    } else {
      const { column } = condition;

      if (!QUERY_CONFIG.allowedFilterColumns.includes(column)) {
        throw new Error(`Invalid filter column: ${column}`);
      }
    }
  });
}


---

3. Build the Query with Relational Mapping

This prepares the where condition and handles relational models dynamically.

private buildWhereQuery(payload: any, include: any[]): WhereOptions {
  const { logicOperator, conditions } = payload;

  if (!conditions || !Array.isArray(conditions)) {
    return {};
  }

  const query = conditions.map((condition) => {
    if (condition.logicOperator) {
      // Recursive call for nested conditions
      return this.buildWhereQuery(condition, include);
    } else {
      const { column, operator, value } = condition;

      const columnInfo = QUERY_CONFIG.columnMapping[column];
      if (!columnInfo) {
        throw new Error(`Column mapping not found for: ${column}`);
      }

      // If the column belongs to a relational table, add it to the `include` array
      if (!columnInfo.isBaseModel) {
        const existingInclude = include.find((i) => i.as === columnInfo.as);

        if (!existingInclude) {
          include.push({
            model: columnInfo.model,
            as: columnInfo.as,
          });
        }
      }

      // Return the condition
      return {
        [columnInfo.column]: { [Sequelize.Op[operator.toLowerCase()]]: value },
      };
    }
  });

  return { [Sequelize.Op[logicOperator.toLowerCase()]]: query };
}


---

4. Combine include and where Query

This ties everything together to generate the final Sequelize query.

async buildQuery(payload: any) {
  // Validate payload columns
  this.validatePayloadColumns(payload);

  const include: any[] = [];
  const where = this.buildWhereQuery(payload, include);

  return { where, include };
}


---

Example Usage

Input Payload

const payload = {
  logicOperator: 'AND',
  conditions: [
    { column: 'age', operator: '>', value: 25 },
    { column: 'departmentName', operator: '=', value: 'Engineering' },
  ],
};

Generate Query

const service = new QueryBuilderService();
const { where, include } = await service.buildQuery(payload);

console.log(where);
console.log(include);


---

Output:

Where Query:

{
  [Op.and]: [
    { age: { [Op.gt]: 25 } },
    { name: { [Op.eq]: "Engineering" } }
  ]
}

Include Array:

[
  {
    "model": "Department",
    "as": "department"
  }
]


---

This implementation ensures:

1. Validation: Only allowed filter/sort columns are passed.


2. Relational Columns: Dynamically adds associated models to the include array.


3. Flexibility: Handles nested conditions and supports both AND/OR.



Let me know if you need further assistance!

When prepare where query add as key in the query_config const

If you want to dynamically add the as key into the prepared where query, you can adjust the logic so that the as information from the QUERY_CONFIG is included in the generated conditions. Here's the updated implementation:


---

Updated Constant with as

const QUERY_CONFIG = {
  allowedFilterColumns: ['age', 'city', 'salary', 'position', 'country', 'departmentName'],
  allowedSortColumns: ['age', 'salary', 'departmentName'],
  columnMapping: {
    age: { column: 'age', model: 'BaseModel', as: null, isBaseModel: true },
    city: { column: 'city', model: 'BaseModel', as: null, isBaseModel: true },
    salary: { column: 'salary', model: 'BaseModel', as: null, isBaseModel: true },
    position: { column: 'position', model: 'BaseModel', as: null, isBaseModel: true },
    country: { column: 'country', model: 'BaseModel', as: null, isBaseModel: true },
    departmentName: {
      column: 'name',
      model: 'Department',
      as: 'department',
      isBaseModel: false,
    },
  },
};


---

Updated Query Builder Logic

This modified logic ensures the as key is included in the final where query when applicable.

1. Build the Where Query

private buildWhereQuery(payload: any, include: any[]): WhereOptions {
  const { logicOperator, conditions } = payload;

  if (!conditions || !Array.isArray(conditions)) {
    return {};
  }

  const query = conditions.map((condition) => {
    if (condition.logicOperator) {
      // Recursive call for nested conditions
      return this.buildWhereQuery(condition, include);
    } else {
      const { column, operator, value } = condition;

      const columnInfo = QUERY_CONFIG.columnMapping[column];
      if (!columnInfo) {
        throw new Error(`Column mapping not found for: ${column}`);
      }

      // If the column belongs to a relational table, add it to the `include` array
      if (!columnInfo.isBaseModel) {
        const existingInclude = include.find((i) => i.as === columnInfo.as);

        if (!existingInclude) {
          include.push({
            model: columnInfo.model,
            as: columnInfo.as,
          });
        }
      }

      // Add `as` key for relational table columns
      return {
        [columnInfo.as || columnInfo.column]: {
          [Sequelize.Op[operator.toLowerCase()]]: value,
        },
      };
    }
  });

  return { [Sequelize.Op[logicOperator.toLowerCase()]]: query };
}


---

2. Generate Query

This method combines everything together.

async buildQuery(payload: any) {
  // Validate payload columns
  this.validatePayloadColumns(payload);

  const include: any[] = [];
  const where = this.buildWhereQuery(payload, include);

  return { where, include };
}


---

Example Usage

Input Payload

const payload = {
  logicOperator: 'AND',
  conditions: [
    { column: 'age', operator: '>', value: 25 },
    { column: 'departmentName', operator: '=', value: 'Engineering' },
  ],
};

Generate Query

const service = new QueryBuilderService();
const { where, include } = await service.buildQuery(payload);

console.log(where);
console.log(include);


---

Output:

Where Query:

{
  [Op.and]: [
    { age: { [Op.gt]: 25 } },
    { department: { [Op.eq]: "Engineering" } }
  ]
}

Include Array:

[
  {
    "model": "Department",
    "as": "department"
  }
]


---

Key Changes:

1. as Key in Query:

Relational columns (departmentName) use their as key from the QUERY_CONFIG for proper aliasing.



2. Dynamic Include:

Adds relational models (Department) to the include array only if they aren't already included.




Let me know if you need further refinements!

Let me include my code. Incorporate your code into mine.

Please share your code, and I will incorporate the dynamic query builder logic into it seamlessly while retaining your structure and logic.

Payload { filter: [ { "operator": "contains", "fieldName": "name", "value": "txt1" }, { "operator": "between", "fieldName": "id", "from": "1", "to": "10" } ], sort: [ { "fieldName": "name", "orderBy": "ASC" }, { "fieldName": "id", "orderBy": "DESC" } ] } Column mapping const { id: { isBaseModel: true, column: "ID", model: RefCostBookTechnology, as: "RefCostBookTechnology" }, costbook_code: { isBaseModel: true, column: "CostBookCode", model: RefCostBookTechnology, as: "RefCostBookTechnology" }, technology_id: { isBaseModel: true, column: "TechnologyID", model: RefCostBookTechnology, as: "RefCostBookTechnology" } },

controller: { queryBuilder: await buildSortFilterQuery(input, queryBuilder); return queryBuilder.query; } buildSortFilterQuery function export const buildSortFilterQuery = async (payload: any, query: any = {}) => { query = { attributes: undefined, include: undefined, where: undefined, order: undefined, }; ...query, try { query = await filterMethod(query, payload); query = await sortMethod(query, payload); console.log(JSON.stringify(query), "Final Query"); return query; } catch (error) { console.error("Error building query:", error); throw error; } }; filter function export const filterMethod = async (query: any, payload: any) => { const { filter, options: { columnMapping } } = payload; let { where = [], include = [] } = query.query; if (filter) { filter.forEach(({ operator, fieldName, value = "", from = "", to = "" }) => { const { isBaseModel, model, as } = columnMapping[fieldName]; const fullyQualifiedColumn = getQualifiedName(operator, columnMapping[fieldName]); const whereClause = getWhereObject({ fieldName: fullyQualifiedColumn, operator, value, from, to }); if (isBaseModel) { where = [...where, ...whereClause]; } else { let includeItem = include.find((item) => item.model === model); if (!includeItem) { include.push({ model, as, where: whereClause }); } else { includeItem.where = { ...includeItem.where, ...whereClause }; } } }); query.query.where = where; query.query.include = include; } return query; }; sort function export const sortMethod = async (query: any, payload: any) => { const { sort, options } = payload; const { columnMapping } = options; let include = query.query.include || undefined || [] || query.query.include; let order = query.query.order || []; if (sort) { for (const { fieldName, orderBy } of sort) { const fieldConfig = columnMapping[fieldName]; if (fieldConfig) { order.push([col(${fieldConfig.as}.${fieldConfig.column}), orderBy]); if (fieldConfig.isBaseModel) { const exists = include.some((item) => item.model === fieldConfig.model); if (!exists) { include.push({ model: fieldConfig.model, as: fieldConfig.as, }); } } } } } query.query.include = include; query.query.order = order; return query; }; export const getQualifiedName = (operator, mapping) => { const { column, qualifiedName } = mapping; if (["in", "dateIn", "nin", "dateNotIn"].includes(operator)) { return qualifiedName ? qualifiedName : column; } return column; }; export function getWhereObject(input) { let { fieldName, operator, value = "", from = "", to = "" } = input; value = value.toString(); // Don't remove this, this line is used to handle common in not when we pass number values const operators = { startsWith: () => ({ [fieldName]: { [Op.iLike]: ${value}% } }), notStartsWith: () => ({ [fieldName]: { [Op.notILike]: ${value}% } }), endsWith: () => ({ [fieldName]: { [Op.iLike]: %${value} } }), notEndsWith: () => ({ [fieldName]: { [Op.notILike]: %${value} } }), contains: () => ({ [fieldName]: { [Op.iLike]: %${value}% } }), notContains: () => ({ [fieldName]: { [Op.notILike]: %${value}% } }), equals: () => ({ [fieldName]: value }), notEquals: () => ({ [fieldName]: { [Op.not]: value } }), between: () => ({ [fieldName]: { [Op.between]: [from, to] } }), notBetween: () => ({ [fieldName]: { [Op.notBetween]: [from, to] } }), gte: () => ({ [fieldName]: { [Op.gte]: value } }), lte: () => ({ [fieldName]: { [Op.lte]: value } }), gteDate: () => ({ [fieldName]: { [Op.gte]: fn("DATE", value) } }), lteDate: () => ({ [fieldName]: { [Op.lte]: fn("DATE", value) } }), date: () => ({ [Op.and]: [{ [fieldName]: Sequelize.where(Sequelize.fn("DATE", Sequelize.col(fieldName)), "=", value) }] }), betweenDate: () => ({ [fieldName]: { [Op.between]: [fn("DATE", from), fn("DATE", to)] } }), inBetweenDates: () => ({ [fieldName]: { [Op.between]: [new Date(from), new Date(to)] } }), in: () => ({ [fieldName]: { [Op.in]: value.split(",") } }), notIn: () => ({ [fieldName]: { [Op.notIn]: value.split(",") } }), dateIn: () => ({ [Op.and]: [ Sequelize.where( Sequelize.fn("TO_DATE", Sequelize.fn("to_char", Sequelize.col(fieldName), "YYYY-MM-DD"), "YYYY-MM-DD"), { [Op.in]: value.split(",").map((date) => Sequelize.fn("TO_DATE", date, "YYYY-MM-DD")), } ), ], }), dateNotIn: () => ({ [Op.and]: [ Sequelize.where( Sequelize.fn("TO_DATE", Sequelize.fn("to_char", Sequelize.col(fieldName), "YYYY-MM-DD"), "YYYY-MM-DD"), { [Op.notIn]: value.split(",").map((date) => Sequelize.fn("TO_DATE", date, "YYYY-MM-DD")), } ), ], }), }; return typeof operators[operator] === "function" ? operatorsoperator : {}; }

To incorporate the dynamic query building functionality into your existing code, I will combine the logic from the filterMethod, sortMethod, and buildSortFilterQuery functions with the relational column handling and validation you've requested.

Here's how we can adjust your current code to integrate the logic:


---

1. Column Mapping Adjustments

You already have a column mapping structure, and I'll keep it the same while integrating relational table handling in the filter and sort methods.

const columnMapping = {
    id: {
        isBaseModel: true,
        column: "ID",
        model: RefCostBookTechnology,
        as: "RefCostBookTechnology"
    },
    costbook_code: {
        isBaseModel: true,
        column: "CostBookCode",
        model: RefCostBookTechnology,
        as: "RefCostBookTechnology"
    },
    technology_id: {
        isBaseModel: true,
        column: "TechnologyID",
        model: RefCostBookTechnology,
        as: "RefCostBookTechnology"
    }
};


---

2. Enhance filterMethod to Handle Relational Columns

We'll modify the filterMethod to handle relational columns and prepare the include array correctly, as well as map the columns using their as property when needed.

export const filterMethod = async (query: any, payload: any) => {
    const { filter, options: { columnMapping } } = payload;
    let { where = [], include = [] } = query.query;

    if (filter) {
        filter.forEach(({ operator, fieldName, value = "", from = "", to = "" }) => {
            const { isBaseModel, model, as } = columnMapping[fieldName];
            const fullyQualifiedColumn = getQualifiedName(operator, columnMapping[fieldName]);
            const whereClause = getWhereObject({ fieldName: fullyQualifiedColumn, operator, value, from, to });

            if (isBaseModel) {
                where = [...where, ...whereClause];
            } else {
                let includeItem = include.find((item) => item.model === model);
                if (!includeItem) {
                    include.push({ model, as, where: whereClause });
                } else {
                    includeItem.where = { ...includeItem.where, ...whereClause };
                }
            }
        });
        query.query.where = where;
        query.query.include = include;
    }

    return query;
};


---

3. Enhance sortMethod for Relational Columns

The sortMethod also needs to correctly handle relational columns when sorting, which includes adding them to the include array if necessary.

export const sortMethod = async (query: any, payload: any) => {
    const { sort, options } = payload;
    const { columnMapping } = options;
    let include = query.query.include || [];
    let order = query.query.order || [];

    if (sort) {
        for (const { fieldName, orderBy } of sort) {
            const fieldConfig = columnMapping[fieldName];
            if (fieldConfig) {
                order.push([col(`${fieldConfig.as}.${fieldConfig.column}`), orderBy]);

                // Ensure relational model is added to include array if not already present
                if (!fieldConfig.isBaseModel) {
                    const exists = include.some((item) => item.model === fieldConfig.model);
                    if (!exists) {
                        include.push({
                            model: fieldConfig.model,
                            as: fieldConfig.as
                        });
                    }
                }
            }
        }
    }

    query.query.include = include;
    query.query.order = order;

    return query;
};


---

4. The buildSortFilterQuery Function

Now, we need to modify the buildSortFilterQuery function to use these methods to generate the full query.

export const buildSortFilterQuery = async (payload: any, query: any = {}) => {
    query = {
        attributes: undefined,
        include: undefined,
        where: undefined,
        order: undefined,
    };

    try {
        // Filter Method to handle WHERE clause
        query = await filterMethod(query, payload);

        // Sort Method to handle ORDER BY clause
        query = await sortMethod(query, payload);

        console.log(JSON.stringify(query), "Final Query");
        return query;
    } catch (error) {
        console.error("Error building query:", error);
        throw error;
    }
};


---

5. Updated getWhereObject Function

This function remains unchanged but ensures that when we need to add conditions (like contains, equals, etc.), it handles both base and relational columns.

export function getWhereObject(input) {
    let { fieldName, operator, value = "", from = "", to = "" } = input;
    value = value.toString(); // Ensure value is a string to handle number conditions

    const operators = {
        startsWith: () => ({ [fieldName]: { [Op.iLike]: `${value}%` } }),
        notStartsWith: () => ({ [fieldName]: { [Op.notILike]: `${value}%` } }),
        endsWith: () => ({ [fieldName]: { [Op.iLike]: `%${value}` } }),
        notEndsWith: () => ({ [fieldName]: { [Op.notILike]: `%${value}` } }),
        contains: () => ({ [fieldName]: { [Op.iLike]: `%${value}%` } }),
        notContains: () => ({ [fieldName]: { [Op.notILike]: `%${value}%` } }),
        equals: () => ({ [fieldName]: value }),
        notEquals: () => ({ [fieldName]: { [Op.not]: value } }),
        between: () => ({ [fieldName]: { [Op.between]: [from, to] } }),
        notBetween: () => ({ [fieldName]: { [Op.notBetween]: [from, to] } }),
        gte: () => ({ [fieldName]: { [Op.gte]: value } }),
        lte: () => ({ [fieldName]: { [Op.lte]: value } }),
        gteDate: () => ({ [fieldName]: { [Op.gte]: fn("DATE", value) } }),
        lteDate: () => ({ [fieldName]: { [Op.lte]: fn("DATE", value) } }),
        date: () => ({ [Op.and]: [{ [fieldName]: Sequelize.where(Sequelize.fn("DATE", Sequelize.col(fieldName)), "=", value) }] }),
        betweenDate: () => ({ [fieldName]: { [Op.between]: [fn("DATE", from), fn("DATE", to)] } }),
        inBetweenDates: () => ({ [fieldName]: { [Op.between]: [new Date(from), new Date(to)] } }),
        in: () => ({ [fieldName]: { [Op.in]: value.split(",") } }),
        notIn: () => ({ [fieldName]: { [Op.notIn]: value.split(",") } }),
        dateIn: () => ({
            [Op.and]: [
                Sequelize.where(
                    Sequelize.fn("TO_DATE", Sequelize.fn("to_char", Sequelize.col(fieldName), "YYYY-MM-DD"), "YYYY-MM-DD"),
                    {
                        [Op.in]: value.split(",").map((date) => Sequelize.fn("TO_DATE", date, "YYYY-MM-DD")),
                    }
                ),
            ],
        }),
        dateNotIn: () => ({
            [Op.and]: [
                Sequelize.where(
                    Sequelize.fn("TO_DATE", Sequelize.fn("to_char", Sequelize.col(fieldName), "YYYY-MM-DD"), "YYYY-MM-DD"),
                    {
                        [Op.notIn]: value.split(",").map((date) => Sequelize.fn("TO_DATE", date, "YYYY-MM-DD")),
                    }
                ),
            ],
        }),
    };
    return typeof operators[operator] === "function" ? operators[operator]() : {};
}


---

Example Usage in Controller:

const payload = {
    filter: [
        {
            operator: "contains",
            fieldName: "name",
            value: "txt1"
        },
        {
            operator: "between",
            fieldName: "id",
            from: "1",
            to: "10"
        }
    ],
    sort: [
        {
            fieldName: "name",
            orderBy: "ASC"
        },
        {
            fieldName: "id",
            orderBy: "DESC"
        }
    ]
};

const query = await buildSortFilterQuery(payload, {
    query: {
        where: [],
        include: [],
        order: [],
    },
    options: { columnMapping }
});

console.log("Generated Query: ", query);


---

This should now seamlessly integrate into your existing structure, ensuring relational columns are dynamically handled in both the filter and sort methods. Let me know if anything needs adjustment!

The payload should also support

const payload = { logicOperator: 'AND', conditions: [ { column: 'age', operator: '>', value: 25 }, { column: 'departmentName', operator: '=', value: 'Engineering' }, ], };

To integrate the new logicOperator and conditions structure into your existing logic, we need to modify both the filterMethod and getWhereObject functions. The goal is to allow the query to dynamically handle the AND or OR logical operators between conditions.

Here’s how to incorporate this change:

1. Updated Payload Structure

The updated payload would look like this:

const payload = {
  logicOperator: 'AND',  // 'AND' or 'OR'
  conditions: [
    { column: 'age', operator: '>', value: 25 },
    { column: 'departmentName', operator: '=', value: 'Engineering' },
  ],
};

2. Modifying the filterMethod to Handle logicOperator and conditions

We will iterate over the conditions and create a where clause based on the logicOperator (AND/OR).

export const filterMethod = async (query: any, payload: any) => {
    const { conditions, logicOperator = 'AND', options: { columnMapping } } = payload;
    let { where = [], include = [] } = query.query;

    if (conditions) {
        // Create an array of conditions based on the logic operator
        const conditionList = conditions.map(({ column, operator, value, from, to }) => {
            const { isBaseModel, model, as } = columnMapping[column];
            const fullyQualifiedColumn = getQualifiedName(operator, columnMapping[column]);
            const whereClause = getWhereObject({ fieldName: fullyQualifiedColumn, operator, value, from, to });

            if (isBaseModel) {
                return whereClause;
            } else {
                let includeItem = include.find((item) => item.model === model);
                if (!includeItem) {
                    include.push({ model, as, where: whereClause });
                } else {
                    includeItem.where = { ...includeItem.where, ...whereClause };
                }
            }
        });

        // Combine conditions based on the logicOperator (AND/OR)
        if (logicOperator === 'AND') {
            where = [...where, ...conditionList];
        } else if (logicOperator === 'OR') {
            where = [...where, { [Op.or]: conditionList }];
        }

        query.query.where = where;
        query.query.include = include;
    }

    return query;
};

3. Modifying getWhereObject to Handle the New Payload Structure

Since you're passing column, operator, and value directly, we don't need major changes to getWhereObject, but we will make sure it handles the conditions correctly.

export function getWhereObject(input) {
    let { fieldName, operator, value = "", from = "", to = "" } = input;
    value = value.toString(); // Ensure value is a string for number conditions

    const operators = {
        startsWith: () => ({ [fieldName]: { [Op.iLike]: `${value}%` } }),
        notStartsWith: () => ({ [fieldName]: { [Op.notILike]: `${value}%` } }),
        endsWith: () => ({ [fieldName]: { [Op.iLike]: `%${value}` } }),
        notEndsWith: () => ({ [fieldName]: { [Op.notILike]: `%${value}` } }),
        contains: () => ({ [fieldName]: { [Op.iLike]: `%${value}%` } }),
        notContains: () => ({ [fieldName]: { [Op.notILike]: `%${value}%` } }),
        equals: () => ({ [fieldName]: value }),
        notEquals: () => ({ [fieldName]: { [Op.not]: value } }),
        between: () => ({ [fieldName]: { [Op.between]: [from, to] } }),
        notBetween: () => ({ [fieldName]: { [Op.notBetween]: [from, to] } }),
        gte: () => ({ [fieldName]: { [Op.gte]: value } }),
        lte: () => ({ [fieldName]: { [Op.lte]: value } }),
        gteDate: () => ({ [fieldName]: { [Op.gte]: fn("DATE", value) } }),
        lteDate: () => ({ [fieldName]: { [Op.lte]: fn("DATE", value) } }),
        date: () => ({ [Op.and]: [{ [fieldName]: Sequelize.where(Sequelize.fn("DATE", Sequelize.col(fieldName)), "=", value) }] }),
        betweenDate: () => ({ [fieldName]: { [Op.between]: [fn("DATE", from), fn("DATE", to)] } }),
        inBetweenDates: () => ({ [fieldName]: { [Op.between]: [new Date(from), new Date(to)] } }),
        in: () => ({ [fieldName]: { [Op.in]: value.split(",") } }),
        notIn: () => ({ [fieldName]: { [Op.notIn]: value.split(",") } }),
        dateIn: () => ({
            [Op.and]: [
                Sequelize.where(
                    Sequelize.fn("TO_DATE", Sequelize.fn("to_char", Sequelize.col(fieldName), "YYYY-MM-DD"), "YYYY-MM-DD"),
                    {
                        [Op.in]: value.split(",").map((date) => Sequelize.fn("TO_DATE", date, "YYYY-MM-DD")),
                    }
                ),
            ],
        }),
        dateNotIn: () => ({
            [Op.and]: [
                Sequelize.where(
                    Sequelize.fn("TO_DATE", Sequelize.fn("to_char", Sequelize.col(fieldName), "YYYY-MM-DD"), "YYYY-MM-DD"),
                    {
                        [Op.notIn]: value.split(",").map((date) => Sequelize.fn("TO_DATE", date, "YYYY-MM-DD")),
                    }
                ),
            ],
        }),
    };

    return typeof operators[operator] === "function" ? operators[operator]() : {};
}

4. Updated buildSortFilterQuery to Incorporate the LogicOperator

The buildSortFilterQuery will now pass the logicOperator and conditions structure to the filterMethod.

export const buildSortFilterQuery = async (payload: any, query: any = {}) => {
    query = {
        attributes: undefined,
        include: undefined,
        where: undefined,
        order: undefined,
    };

    try {
        // Filter Method to handle WHERE clause
        query = await filterMethod(query, payload);

        // Sort Method to handle ORDER BY clause
        query = await sortMethod(query, payload);

        console.log(JSON.stringify(query), "Final Query");
        return query;
    } catch (error) {
        console.error("Error building query:", error);
        throw error;
    }
};


---

Example Usage in Controller:

Now, your controller can receive the updated payload with logicOperator and conditions, and the query will be built accordingly.

const payload = {
    logicOperator: 'AND',  // OR or AND
    conditions: [
        { column: 'age', operator: '>', value: 25 },
        { column: 'departmentName', operator: '=', value: 'Engineering' },
    ],
    sort: [
        { fieldName: 'name', orderBy: 'ASC' },
        { fieldName: 'id', orderBy: 'DESC' }
    ]
};

const query = await buildSortFilterQuery(payload, {
    query: {
        where: [],
        include: [],
        order: [],
    },
    options: { columnMapping }
});

console.log("Generated Query: ", query);


---

Final Thoughts:

Logic Operator: The logicOperator (AND/OR) in the payload determines how the conditions are combined.

Conditions: Each condition contains a column, operator, and value (or range, for between).

Relational Columns: If a condition refers to a relational column (e.g., department.name), the logic for including the necessary include and where clauses for relations is handled.


Let me know if further refinements are needed!

You missed sort method

You're right! Let's update the sortMethod to handle the new payload format with logicOperator and conditions. In addition, we'll ensure that the sort functionality works properly alongside the filter functionality. Here's the complete solution:

Updated sortMethod

The sortMethod needs to handle sorting based on the fieldName in the payload and also respect the column mappings to join relational models properly when required.

export const sortMethod = async (query: any, payload: any) => {
    const { sort, options } = payload;
    const { columnMapping } = options;
    let include = query.query.include || [] || query.query.include;
    let order = query.query.order || [];

    if (sort) {
        for (const { fieldName, orderBy } of sort) {
            const fieldConfig = columnMapping[fieldName];

            if (fieldConfig) {
                // Use the alias to support relational columns (like `department.name`)
                order.push([col(`${fieldConfig.as}.${fieldConfig.column}`), orderBy]);

                // Check if the column is from a relational model, add the model to the include array if necessary
                if (fieldConfig.isBaseModel) {
                    const exists = include.some((item) => item.model === fieldConfig.model);
                    if (!exists) {
                        include.push({
                            model: fieldConfig.model,
                            as: fieldConfig.as,
                        });
                    }
                }
            }
        }
    }

    // Attach the include and order clauses to the query
    query.query.include = include;
    query.query.order = order;
    return query;
};

Updated filterMethod

We already updated the filterMethod to handle the new logicOperator and conditions payload structure, which is responsible for building the where clause. Here's the code for filterMethod again for completeness:

export const filterMethod = async (query: any, payload: any) => {
    const { conditions, logicOperator = 'AND', options: { columnMapping } } = payload;
    let { where = [], include = [] } = query.query;

    if (conditions) {
        // Create an array of conditions based on the logic operator
        const conditionList = conditions.map(({ column, operator, value, from, to }) => {
            const { isBaseModel, model, as } = columnMapping[column];
            const fullyQualifiedColumn = getQualifiedName(operator, columnMapping[column]);
            const whereClause = getWhereObject({ fieldName: fullyQualifiedColumn, operator, value, from, to });

            if (isBaseModel) {
                return whereClause;
            } else {
                let includeItem = include.find((item) => item.model === model);
                if (!includeItem) {
                    include.push({ model, as, where: whereClause });
                } else {
                    includeItem.where = { ...includeItem.where, ...whereClause };
                }
            }
        });

        // Combine conditions based on the logicOperator (AND/OR)
        if (logicOperator === 'AND') {
            where = [...where, ...conditionList];
        } else if (logicOperator === 'OR') {
            where = [...where, { [Op.or]: conditionList }];
        }

        query.query.where = where;
        query.query.include = include;
    }

    return query;
};

Updated buildSortFilterQuery

Now, the buildSortFilterQuery will handle both filtering and sorting logic correctly. Here’s the updated version of buildSortFilterQuery:

export const buildSortFilterQuery = async (payload: any, query: any = {}) => {
    query = {
        attributes: undefined,
        include: undefined,
        where: undefined,
        order: undefined,
    };

    try {
        // Apply filter logic
        query = await filterMethod(query, payload);

        // Apply sorting logic
        query = await sortMethod(query, payload);

        console.log(JSON.stringify(query), "Final Query");
        return query;
    } catch (error) {
        console.error("Error building query:", error);
        throw error;
    }
};

Updated Controller Usage

Now, your controller can receive the updated payload with both the filter (conditions and logic operator) and sort parameters:

const payload = {
    logicOperator: 'AND',  // OR or AND
    conditions: [
        { column: 'age', operator: '>', value: 25 },
        { column: 'departmentName', operator: '=', value: 'Engineering' },
    ],
    sort: [
        { fieldName: 'name', orderBy: 'ASC' },
        { fieldName: 'id', orderBy: 'DESC' }
    ]
};

const query = await buildSortFilterQuery(payload, {
    query: {
        where: [],
        include: [],
        order: [],
    },
    options: { columnMapping }
});

console.log("Generated Query: ", query);

Summary

filterMethod: Handles filtering conditions using logicOperator (AND/OR) and conditions provided in the payload. The relational columns (e.g., department.name) are also handled dynamically.

sortMethod: Adds sorting logic, ensuring relational columns (e.g., department.name) are properly joined and included in the query.

buildSortFilterQuery: Combines both filterMethod and sortMethod to construct the final query based on the provided payload.


This should allow you to generate queries that handle complex filtering and sorting logic, including relational tables and conditions.

Let me know if you need further adjustments!

